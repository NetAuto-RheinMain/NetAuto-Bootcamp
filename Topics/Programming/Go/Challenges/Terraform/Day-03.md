# **Day 3: Implementing CRUD Operations (Create & Read)**

## **Objective:** 
Implement the `Create` and `Read` operations for our resource, interacting with the "Greeting API".

## **Create Operation (`Create` method):**

1.  Retrieve input values from `req.Plan.Get()`.
2.  Call your API client (from `api_client.go`).
3.  Set the resource state using `resp.State.Set()`.

## **Read Operation (`Read` method):**

1.  Retrieve the current state from `req.State.Get()`.
2.  Call your API client to fetch the resource by ID.
3.  If the resource doesn't exist (e.g., API returns 404), clear the ID in the state (`resp.State.RemoveResource()`).
4.  Set fetched values back to `resp.State.Set()`.

## **Error Handling and Diagnostics (`diag.Diagnostics`):**

  * Use `resp.Diagnostics.AddError()` and `resp.Diagnostics.AddWarning()` for structured error reporting.

## **Challenges:**

  * Converting between framework types (`types.String`) and native Go types (`string`).
  * Correctly handling API errors and translating them into Terraform diagnostics.
  * Ensuring the `Read` operation correctly handles resources that no longer exist in the API.

## **Code Example (Day 3 - Update `resource_greeting_message.go` and `api_client.go`):**

**First, ensure your `api_client.go` is ready (this file should be the same as the one provided in the previous response, but included here for completeness and context):**

**(File: `terraform-provider-greeting-framework/api_client.go`)**

```go
package main // Keep it in the 'main' package for simplicity in this tutorial

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
)

// Greeting represents the data structure for our API's greeting messages.
// Matches the JSON fields from the Go API server.
type Greeting struct {
	ID      string `json:"id,omitempty"` // omitempty: ID is generated by the API on creation
	Message string `json:"message"`
	Author  string `json:"author,omitempty"`
}

// CreateGreeting sends a POST request to the API to create a new greeting.
func (c *apiClient) CreateGreeting(ctx context.Context, msg, author string) (*Greeting, error) {
	reqBody := Greeting{
		Message: msg,
		Author:  author,
	}

	jsonBody, err := json.Marshal(reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, fmt.Sprintf("%s/greetings", c.BaseURL), bytes.NewBuffer(jsonBody))
	if err != nil {
		return nil, fmt.Errorf("failed to create new HTTP request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	// If your API needed an API key in the header:
	// req.Header.Set("Authorization", "Bearer " + c.APIKey)

	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to make HTTP POST request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusCreated {
		bodyBytes, _ := ioutil.ReadAll(resp.Body)
		return nil, fmt.Errorf("API returned non-201 status for create (Status: %d, Body: %s)", resp.StatusCode, string(bodyBytes))
	}

	var createdGreeting Greeting
	if err := json.NewDecoder(resp.Body).Decode(&createdGreeting); err != nil {
		return nil, fmt.Errorf("failed to decode create response: %w", err)
	}

	return &createdGreeting, nil
}

// GetGreetingByID sends a GET request to the API to retrieve a greeting by ID.
func (c *apiClient) GetGreetingByID(ctx context.Context, id string) (*Greeting, error) {
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, fmt.Sprintf("%s/greetings/%s", c.BaseURL, id), nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create new HTTP request: %w", err)
	}

	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to make HTTP GET request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusNotFound {
		return nil, nil // Return nil, nil if not found (Terraform Read will handle removing resource from state)
	}

	if resp.StatusCode != http.StatusOK {
		bodyBytes, _ := ioutil.ReadAll(resp.Body)
		return nil, fmt.Errorf("API returned non-200 status for get by ID (Status: %d, Body: %s)", resp.StatusCode, string(bodyBytes))
	}

	var greeting Greeting
	if err := json.NewDecoder(resp.Body).Decode(&greeting); err != nil {
		return nil, fmt.Errorf("failed to decode get by ID response: %w", err)
	}

	return &greeting, nil
}

// UpdateGreeting sends a PUT request to the API to update an existing greeting.
func (c *apiClient) UpdateGreeting(ctx context.Context, id, msg, author string) (*Greeting, error) {
	reqBody := Greeting{
		Message: msg,
		Author:  author,
	}

	jsonBody, err := json.Marshal(reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal update request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodPut, fmt.Sprintf("%s/greetings/%s", c.BaseURL, id), bytes.NewBuffer(jsonBody))
	if err != nil {
		return nil, fmt.Errorf("failed to create new HTTP request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")

	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to make HTTP PUT request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		bodyBytes, _ := ioutil.ReadAll(resp.Body)
		return nil, fmt.Errorf("API returned non-200 status for update (Status: %d, Body: %s)", resp.StatusCode, string(bodyBytes))
	}

	var updatedGreeting Greeting
	if err := json.NewDecoder(resp.Body).Decode(&updatedGreeting); err != nil {
		return nil, fmt.Errorf("failed to decode update response: %w", err)
	}

	return &updatedGreeting, nil
}

// DeleteGreeting sends a DELETE request to the API to remove a greeting.
func (c *apiClient) DeleteGreeting(ctx context.Context, id string) error {
	req, err := http.NewRequestWithContext(ctx, http.MethodDelete, fmt.Sprintf("%s/greetings/%s", c.BaseURL, id), nil)
	if err != nil {
		return fmt.Errorf("failed to create new HTTP request: %w", err)
	}

	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return fmt.Errorf("failed to make HTTP DELETE request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusNoContent { // 204 No Content expected for successful delete
		bodyBytes, _ := ioutil.ReadAll(resp.Body)
		return fmt.Errorf("API returned non-204 status for delete (Status: %d, Body: %s)", resp.StatusCode, string(bodyBytes))
	}

	return nil
}

```

**Now, update `terraform-provider-greeting-framework/resource_greeting_message.go`:**

```go
package main

import (
	"context"
	"fmt"
	"log" // Good for debugging

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// Ensure the implementation satisfies the tfsdk.ResourceTypeWith
// and tfsdk.Resource interfaces.
var _ tfsdk.ResourceTypeWith
var _ tfsdk.Resource = &greetingResource{}

// greetingResourceType defines the resource type.
type greetingResourceType struct{}

// GetSchema defines the schema for the greeting_message resource.
func (r greetingResourceType) GetSchema(ctx context.Context) (tfsdk.Schema, diag.Diagnostics) {
	return tfsdk.Schema{
		Description: "Manages a greeting message.",
		Attributes: map[string]tfsdk.Attribute{
			"id": {
				Description: "Unique ID of the greeting.",
				Type:        types.StringType,
				Computed:    true,
			},
			"message": {
				Description: "The greeting message.",
				Type:        types.StringType,
				Required:    true,
			},
			"author": {
				Description: "The author of the greeting.",
				Type:        types.StringType,
				Optional:    true,
				Computed:    true,
			},
		},
	}, nil
}

// NewResource creates a new resource instance.
func (r greetingResourceType) NewResource(ctx context.Context, p tfsdk.Provider) (tfsdk.Resource, diag.Diagnostics) {
	// Cast the provider interface to our specific provider type to access the client.
	provider, ok := p.(*greetingProvider)
	if !ok {
		return nil, diag.Diagnostics{
			diag.NewErrorDiagnostic("Unexpected Provider Type", "Expected *greetingProvider."),
		}
	}
	return &greetingResource{
		client: provider.client, // Pass the configured API client
	}, nil
}

// greetingResource implements the tfsdk.Resource interface.
type greetingResource struct {
	client *apiClient // Our API client instance
}

// GreetingModel defines the Go model for the greeting_message resource.
type GreetingModel struct {
	ID      types.String `tfsdk:"id"`
	Message types.String `tfsdk:"message"`
	Author  types.String `tfsdk:"author"`
}

// Create handles resource creation.
func (r *greetingResource) Create(ctx context.Context, req tfsdk.CreateResourceRequest, resp *tfsdk.CreateResourceResponse) {
	var plan GreetingModel

	// Read the plan (user's configuration) into our Go model.
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Extract values from the plan.
	message := plan.Message.ValueString()
	author := plan.Author.ValueString()

	// Call the API client to create the greeting.
	createdGreeting, err := r.client.CreateGreeting(ctx, message, author)
	if err != nil {
		resp.Diagnostics.AddError("Error creating greeting", fmt.Sprintf("Could not create greeting: %s", err.Error()))
		return
	}

	// Update the plan with the ID and any computed values from the API.
	plan.ID = types.StringValue(createdGreeting.ID)
	plan.Message = types.StringValue(createdGreeting.Message)
	plan.Author = types.StringValue(createdGreeting.Author) // API might have set a default author

	log.Printf("[INFO] Created greeting with ID: %s", createdGreeting.ID)

	// Set the state for the resource.
	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
}

// Read handles resource reading.
func (r *greetingResource) Read(ctx context.Context, req tfsdk.ReadResourceRequest, resp *tfsdk.ReadResourceResponse) {
	var state GreetingModel

	// Read the current state into our Go model.
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	greetingID := state.ID.ValueString()
	if greetingID == "" {
		// This can happen if the resource was deleted externally or never created properly.
		// In this case, we remove it from state.
		resp.State.RemoveResource(ctx)
		log.Printf("[WARN] Attempted to read resource with empty ID, removing from state.")
		return
	}

	// Call the API client to get the greeting by ID.
	greeting, err := r.client.GetGreetingByID(ctx, greetingID)
	if err != nil {
		resp.Diagnostics.AddError("Error reading greeting", fmt.Sprintf("Could not read greeting with ID %s: %s", greetingID, err.Error()))
		return
	}

	if greeting == nil {
		// Resource not found in the API (e.g., 404), mark for recreation in Terraform state.
		resp.State.RemoveResource(ctx)
		log.Printf("[INFO] Greeting with ID %s not found in API, removing from state.", greetingID)
		return
	}

	// Update the state based on the API response.
	state.ID = types.StringValue(greeting.ID)
	state.Message = types.StringValue(greeting.Message)
	state.Author = types.StringValue(greeting.Author)

	log.Printf("[INFO] Read greeting with ID: %s", greetingID)

	// Set the updated state for the resource.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Placeholder Update and Delete (will be updated on Day 4)
func (r *greetingResource) Update(ctx context.Context, req tfsdk.UpdateResourceRequest, resp *tfsdk.UpdateResourceResponse) {
	resp.Diagnostics.AddError("Update not implemented", "The Update function for greeting_message is not yet implemented.")
}

func (r *greetingResource) Delete(ctx context.Context, req tfsdk.DeleteResourceRequest, resp *tfsdk.DeleteResourceResponse) {
	resp.Diagnostics.AddError("Delete not implemented", "The Delete function for greeting_message is not yet implemented.")
}

// ImportState is used to import existing resources into Terraform state.
func (r *greetingResource) ImportState(ctx context.Context, req tfsdk.ImportResourceStateRequest, resp *tfsdk.ImportResourceStateResponse) {
	// For simple resources, setting the ID is often enough.
	tfsdk.State{}.SetAttribute(ctx, resp.State, "id", req.ID)
}
```
